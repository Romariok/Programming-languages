#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+INCLUDE: "../common/org-header.org"

#+TITLE: Семинар 4: Виртуальная память, загрузка программ

* Что такое виртуальная память

  Виртуальная память это абстракция над с физической памятью. Она создаёт для программы иллюзию того, что кроме неё в памяти ничего нет.

  Каждый процесс оказывается изолирован от других в своем собственном адресном пространстве. Адресное пространство процесса разделено на страницы одинакового размера, обычно 4КБ. Страницы, таким образом, не могут начинаться с произвольного адреса, а только с адреса кратного 4КБ.

  Операционная система управляет этими страницами, например, вытесняет в файл подкачки и возвращает обратно при необходимости.

  Большинство адресов запрещены:  значения, которые по ним находятся, не определены, и попытка доступа
  к ним приводит к ошибке. Эта ситуация обычно приводит к аварийному завершению программы.

  Linux и другие системы на базе Unix используют механизм сигналов для уведомления
  применение в исключительных ситуациях. Можно назначить обработчик практически для всех
  типов сигналов. Доступ к запрещенному адресу будет перехвачен операционной системой, которая
  передаст приложению сигнал SIGSEGV. В этой ситуации довольно часто можно увидеть сообщение
  об ошибке =Segmentation fault=.

  Обычно страницы соответствуют одному процессу, но могут быть и разделены между процессами.

  Одни страницы соответствуют файлам, взятым из хранилища, например, кускам запущенного исполняемого файла.
  Другие называются /анонимные страницы/, они соответствуют стеку и динамически выделяемой памяти (куча, heap).

  У страниц есть набор флагов. Они включают, но не ограничиваются, разрешениями на чтение, запись, и выполнение кода со страниц.

  Сопоставление страницам сущностей (файлам, физической памяти) называется memory mapping.
  
* Изучение карты памяти процесса

  Сегодня мы изучим слепок виртуальной памяти процесса.
  Мы увидим несколько типов страниц:
  
  1. Соответствующих образу исполняемого файла
  2. Соответствующих библиотекам
  3. Анонимные страницы стека и кучи
  4. Пустые регионы запрещённых адресов

  В Linux есть механизм доступа к структурам ядра, описывающим состояние процессов, в том числе и виртуальной памяти. Он называется =procfs=. Это специальная файловая система, примонтированная в директории =/proc=, в которой с помощью навигации по директориям и просмотра файлов можно добраться до памяти любого процесса, до его переменных окружения и т.д. Подробную информацию о =/proc= можно прочитать в =man proc=.

  *Вопрос* посмотрите, какие у вас запущены процессы. Выберите один (например, оболочку, которой вы пользуетесь) и посмотрите на содержимое директории =/proc/PID/=, где PID --- его идентификатор.

  *Вопрос* что внутри файла =/proc/PID/environ=?

  *Вопрос* Прочитайте про запуск программ в фоне. Что делают команды =bg=, =fg=, =jobs=?

  Напишем простую программу, которая входит в бесконечный цикл:

  #+BEGIN_SRC asm
      section .data
      correct: dq -1
      section .text
      global _start
      _start:
      jmp _start
  #+END_SRC

 Что она делает? Скомпилируйте и запустите её в фоне.

  *Вопрос* выведите с помощью =cat= содержимое файла =/proc/PID/maps=, где PID --- идентификатор процесса, который вы запустили в фоне.

  Пример вывода может быть таким:

  #+BEGIN_SRC
00400000-00401000 r-xp 00000000 08:01 144225 /home/stud/main
00600000-00601000 rwxp 00000000 08:01 144225 /home/stud/main
7fff11ac0000-7fff11ae1000 rwxp 00000000 00:00 0 [stack]
7fff11bfc000-7fff11bfe000 r-xp 00000000 00:00 0 [vdso]
7fff11bfe000-7fff11c00000 r--p 00000000 00:00 0 [vvar]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]
  #+END_SRC

  Первая колонка это /регион памяти/, который описывается далее в других колонках. Непрерывная область памяти называется /регионом/, если она состоит из целого числа страниц с одинаковыми флагами.

  
  *Вопрос* почему в регионах начальный и конечный адрес в 16-ричном формате заканчиваются всегда на три нуля?

  Разные секции загружаются в разные регионы.

  [[./img/loading.svg]]


  *Вопрос* определите, по каким адресам загружаются секции =.text= и =.data= из примера. Вам может помочь =readelf= и таблица символов.

  *Вопрос* определите хотя бы один запрещённый диапазон адресов.

  *Вопрос* Что такое inode в файловой системе?
  
  *Вопрос* Что находится в остальных столбцах? Прочитайте про файл =/proc/PID/maps= в =man procfs=.


* Использование =mmap=
  
Отображение файла в память (memory mapped files) --- это способ работы с файлами, при котором файлу ставится в соответствие диапазон адресов виртуальной памяти. Операционная система прозрачно для программиста организует этот процесс так, чтобы чтение данных из этих адресов приводило к чтению данных из отображенного файла, а запись данных по этим адресам приводила к записи в файл.

В *nix подобных системах файлы также используются как абстракции для устройств, то есть взаимодействие с файлом означает взаимодействие с устройством. Такие файлы обычно находятся в директории =/dev=. Файлы устройств тоже можно отображать в память.

[[./img/mapped-file.svg]]


Вообще говоря mapping это, буквально,  /отображение/, сопоставление чего-то чему-то. В общем случае мы сопоставляем регионам виртуальной памяти:

- файлы в хранилище
- устройства
- физическую память 

  Это происходит когда загрузчик заполняет адресное пространство процесса, когда процесс запрашивает страницы у операционной системы, когда операционная система отображает файлы по запросу в адресное пространство процесса.
  

Мы уже знаем про то, как использовать [[../master/docs/system-calls.md][системные вызовы]]. Для выполнения всех операций, связанных с отображениями в память, используется системный вызов =mmap=. Его номер (который нужно положить в =rax=) в Linux равен 9.

*Вопрос* прочитайте в =man mmap= ответы на следующие вопросы:
   - Какие аргументы принимает =mmap=? В чём их смысл? Какой аргумент в каком регистре?

Сейчас наша задача создать и запустить минимальный пример с отображением файла в память.

- Откроем файл с помощью системного вызова =open= и получим дескриптор файла.
- Вызовем =mmap= с правильными аргументами.
- Используем подпрограмму =print_string=.

В процессе вам понадобится узнать точные значения некоторых флагов, например, =PROT_READ=.
Вот как их можно найти:

1. В =/usr/include= можно найти заголовочные файлы для Linux API, в которых их точные значения присутствуют. Ищите строчки похожие на =#define PROT_READ= (чтобы учесть пробелы вам пригодятся регулярные выражения).
2. Используйте Linux Cross Reference (lxr), например, [[http://lxr.free-electrons.com]].


*Задание 1* Создайте файл =hello.txt= с текстом =Hello, mmap!=. Используя [[./hello_mmap.asm][заготовку]], отобразите его в память и выведите текст из него в стандартный поток вывода. Не забудьте вызвать =munmap= (его номер системного вызова 11) и закрыть файл (=close=, номер системного вызова 3) по завершению работы с файлом.

#+BEGIN_SRC asm
; hello_mmap.asm
%define O_RDONLY 0 
%define PROT_READ 0x1
%define MAP_PRIVATE 0x2
%define SYS_WRITE 1
%define SYS_OPEN 2
%define SYS_MMAP 9
%define FD_STDOUT 1

section .data
    ; This is the file name. You are free to change it.
    fname: db 'hello.txt', 0

section .text
global _start

; use exit system call to shut down correctly
exit:
    mov  rax, 60
    xor  rdi, rdi
    syscall

; These functions are used to print a null terminated string
; rdi holds a string pointer
print_string:
    push rdi
    call string_length
    pop  rsi
    mov  rdx, rax 
    mov  rax, SYS_WRITE
    mov  rdi, FD_STDOUT
    syscall
    ret

string_length:
    xor  rax, rax
.loop:
    cmp  byte [rdi+rax], 0
    je   .end 
    inc  rax
    jmp .loop 
.end:
    ret

; This function is used to print a substring with given length
; rdi holds a string pointer
; rsi holds a substring length
print_substring:
    mov  rdx, rsi 
    mov  rsi, rdi
    mov  rax, SYS_WRITE
    mov  rdi, FD_STDOUT
    syscall
    ret

_start:
    ; Вызовите open и откройте fname в режиме read only.
    mov  rax, SYS_OPEN
    mov  rdi, fname
    mov  rsi, O_RDONLY    ; Open file read only
    mov  rdx, 0 	  ; We are not creating a file
                          ; so this argument has no meaning
    syscall
    ; rax holds the opened file descriptor now

    ; Вызовите mmap c правильными аргументами
    ; Дайте операционной системе самой выбрать, куда отобразить файл
    ; Размер области возьмите в размер страницы 
    ; Область не должна быть общей для нескольких процессов 
    ; и должна выделяться только для чтения.


    ; с помощью print_string теперь можно вывести его содержимое

    call exit
#+END_SRC 


*Задание 2* Прочитайте документацию по системному вызову =fstat= (номер 5). Вас будет интересовать поле =st_size= типа =off_t= структуры =struct stat=, которую функция =fstat= заполняет. Используйте его, чтобы корректно вычислить размер файла при выводе данных, и выведите их, используя функцию =print_substring= (принимает на вход два аргумента: адрес начала строки и количество байт для вывода). Полученный размер файла используйте в вызовах =mmap=, =munmap= и =print_substring=.

Для выполнения задания вам пригодиться следующая информация:

#+BEGIN_SRC
sizeof(struct stat) = 144
offsetof(struct stat, st_size) = 48
sizeof(off_t) = 8
#+END_SRC 

Для выделения памяти на хранение структуры =stat= рекомендуется использовать стек.

* Вызов ассемблерного кода из C

  В файле =string.asm= содержатся функции =print_string= и =world=:

#+BEGIN_SRC asm
; string.asm
global world
global print_string

section .rodata
message: db ", world!", 10, 0

section .text

string_length:
    mov  rax, 0
    .loop:
      xor  rax, rax
    .count:
      cmp  byte [rdi+rax], 0
      je   .end
      inc  rax
      jmp  .count
    .end:
      ret

world:
    mov rdi, message

print_string:
    push rax
    push rdi
    call string_length
    mov  rsi, [rsp]
    mov  rdx, rax
    mov  rax, 1
    mov  rdi, 1
    push rcx
    syscall
    pop  rcx
    pop  rdi
    pop  rax
    ret
#+END_SRC 
    
  *Вопрос* Что делает функция =world=? Объясните принцип её работы.

  В файле =hello.c= содержится функция =main=, которая вызывает =print_string= и выводит с её помощью "hello" таким способом:

#+BEGIN_SRC с
/* hello.c */
int main() {
    print_string("hello");
    world();
}
#+END_SRC 

  Функция =main= также вызывает =world=.
  
  *Задание 3* В этих файлах не хватает нескольких строчек чтобы можно было взаимодействовать с кодом друг друга. Допишите файлы так, чтобы функции =print_string= и =hello= вызывалась и проверьте результат. Подсказка: вспомните, что нужно, чтобы из одного файла с C-кодом вызвать код из другого файла.

  *Вопрос* Какие аргументы может принимает функция языка С по умолчанию? В чем отличие прототипов =int f();= и =int f(void);=?

  *Вопрос* Изучите =Makefile= [[./makefile][для сборки этой программы]]. Что означают =$@=, =$^=?

  *Вопрос* Что такое секции =.rodata= и =.bss=? 

  *Вопрос* Что в nasm делают директивы =resb=, =resq= и [[https://nasm.us/doc/nasmdoc3.html][другие]]?
  
  *Вопрос* В файле =hello.c=, в какой секции будет выделена строка ="hello"=?

  
* ELF-файлы

  При выполнении задания 3, в процессе компиляции мы получили файлы:

  - =string.o= из ассемблерного файла =string.asm=;
  - =hello.o= из файла с кодом на C =hello.c=;
  - =hello=, исполняемый файл.
    
  Изучим эти файлы более подробно с помощью =readelf=. Чтобы облегчить процесс исследований, записывайте все результаты.

 В ELF-файле есть три заголовка:

 - File header :: основной заголовок, содержит общую информацию о файле и ссылки на два других заголовка.
 - Section header :: список секций (те самые, которые в ассемблере, и многие другие в служебных целях)
 - Program header :: список /сегментов/.
   Каждый сегмент описывает регион памяти, в который будут загружены одна или более секций.
    
 *Вопрос* Введите =readelf= без аргументов. Прочитайте вывод и определите, какие ключи необходимы, чтобы отобразить три заголовка файла.

 *Вопрос* Выведите file header (ключ =-h= или =--file-header=) для файла =hello.o=. Что такое Entry point address и почему его значение 0?

 *Вопрос* Выведите program header (ключ =-l= или =--program-headers=) для файла =hello.o=. Объясните результат.

 *Вопрос* Определите адреса загрузки секций =.text= и =.rodata= используя список секций (ключ =-S= или =--section-headers=).

 *Вопрос* Выведите program header для файла =hello=. В какие сегменты попадают =.text= и =.rodata=? Какие адреса загрузки этих сегментов?

  
* Загрузка файла

 *Вопрос* Модифицируйте программу на C так, чтобы она входила в бесконечный цикл. Это позволит нам проверить наши догадки про адреса секций и сегментов.

 *Вопрос* Выведите карту регионов памяти для запущенной программы, с которой мы сегодня работаем. Сопоставьте сегменты, содержащие секции =.rodata= и =.text= регионам памяти. Верно ли, что одному региону памяти соответствует только один сегмент?

 *Вопрос* Какие регионы соответствуют частям динамических библиотек? У динамических библиотек в Linux расширение =*.so=.
 
 *Вопрос* Выполните =ldd hello=. Объясните результат.

 *Вопрос* Как вы думаете, почему стандартная библиотека C реализована как динамическая библиотека, а не включается в состав исполняемого файла статически, как обычные =.o= файлы?

 *Задание 4* Объедините ассемблерный код для вывода содержимого файла с кодом на языке C. Пусть ваша программа будет просить пользователя ввести название файла, а затем выведет его содержимое в стандартный поток вывода используя код, написанный в начале сегодняшнего семинара (сделайте из него функцию =print_file=, которая будет принимать имя файла первым аргументом). Не забудьте, что для корректной работы необходимо следовать соглашениям о вызовах и сохранить callee-saved регистры, которые вы используете, в начале своей функции =print_file=. Для вывода сообщений (например "Please enter file name: ") используйте собственную реализацию =print_string= из сегодняшнего семинара.


 Желающие могут прочитать больше про регионы =[vdso]= и =[vvar]=, использующиеся для ускорения некоторых системных вызовов:
  
  - =man vdso=
  - [[https://lwn.net/Articles/615809/][Implementing virtual system calls]]


